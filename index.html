<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>テトリス</title>
    <!-- 参考にしたのは https://www.youtube.com/watch?v=LJlKaTwtSdI -->
</head>

<body>
    <h1 id="title">テトリス！</h1>

    <div id="wrapper">
        <div id="tetris">           
            <div id="btn">
                <input type="button" id="start" value="START" onclick="Startbtn()">  <!-- スタートボタンが押されたら関数StartBtn()が動く -->
                <input type="button" id="reset" value="RESET" onclick="ResetBtn()" disabled>  <!-- リセットボタンが押されたら関数ResetBtn()が動く -->
            </div>

            <div id="GO">
                <p id="GAMEOVER"></p>
            </div>
        
            <canvas id="can"></canvas>  <!-- canvasの呼び出し -->
        </div>
    
        
         <div id="document">
            <dl>
                <dt>消したラインの数</dt>
                <dd id="line_c"></dd>
            </dl>
            <hr>
            <dl>
                <dt>スペースキー</dt>
                <dd>回転</dd>
                <dt>→</dt>
                <dd>右に移動</dd>
                <dt>↓</dt>
                <dd>下に移動</dd>
                <dt>←</dt>
                <dd>左に移動</dd>
            </dl>
        </div>
    </div>


    <!-- ここからJavaScript -->
    <script>
        //フィールドのサイズ（10列*20行）
        const FIELD_COL = 10;
        const FIELD_ROW = 20;
        //ブロック１つのサイズ（ピクセル）
        const BLOCK_SIZE = 30;
        //スクリーンサイズ
        const SCREEN_W = BLOCK_SIZE * FIELD_COL;
        const SCREEN_H = BLOCK_SIZE * FIELD_ROW;
        // テトロミノのサイズ
        const TETRO_SIZE = 4;

        //テトリミノが落ちるスピード（ミリ秒）
        let GAME_SPEED=1000;
        // canvasで描画できるように設定
        let can = document.getElementById("can");
        let con = can.getContext('2d');
        //canvasに備わっているプロパティwidthとheightにスクリーンサイズを定義。線もかこう。
        can.width           = SCREEN_W;
        can.height          = SCREEN_H;
        can.style.border    = "4px solid #555";
        // テトロミノ本体の変数定義（ブロックの形を4*4の二次元配列で表現するつもり）
        let tetro;
        //初期位置
        const START_X = FIELD_COL/2 - TETRO_SIZE/2;
        const START_Y = 0;
        //テトロミノの現在の座標
        let tetro_x = START_X;
        let tetro_y = START_Y;
        //フィールドの中身
        let field =[];
        //ゲームオーバーのフラグ
        let gameover = false;
        //１行揃えて消した回数
        let line_count = 0;
        //最終スコア
        let final_line_count;
        //「消したラインの数」の初期値0を表示
        document.getElementById("line_c").innerHTML = line_count;
        //ライン消したときにゲームスピード速くする時の変数
        let NEW_GAME_SPEED;




        //テトロミノの8種類の型を宣言
        const TETRO_TYPES =[
            [], //0 空っぽ
            [  //1 棒
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0],
                [0, 0, 0, 0],       
            ],

            [  //2 L型
                [0, 1, 0, 0],
                [0, 1, 0, 0],
                [0, 1, 1, 0],
                [0, 0, 0, 0],       
            ],

            [  //3 J型
                [0, 0, 1, 0],
                [0, 0, 1, 0],
                [0, 1, 1, 0],
                [0, 0, 0, 0],       
            ],

            [  //4 T型
                [0, 1, 0, 0],
                [0, 1, 1, 0],
                [0, 1, 0, 0],
                [0, 0, 0, 0],       
            ],

            [  //5 O型
                [0, 0, 0, 0],
                [0, 1, 1, 0],
                [0, 1, 1, 0],
                [0, 0, 0, 0],       
            ],

            [  //6 Z型
                [0, 0, 0, 0],
                [1, 1, 0, 0],
                [0, 1, 1, 0],
                [0, 0, 0, 0],       
            ],

            [  //7 S型
                [0, 0, 0, 0],
                [0, 1, 1, 0],
                [1, 1, 0, 0],
                [0, 0, 0, 0],       
            ]

        ];


         //テトロミノの色を宣言しておく
         const TETRO_COLORS =
        [
            "#000",     //0
            "#6CF",     //1
            "#F92",     //2
            "#66F",     //3
            "#C5C",     //4
            "#FD2",     //5
            "#F44",     //6
            "#5B5"      //7
        ];

        
        //テトロミノの形をランダムで出す
        let num;
        num = Math.floor(Math.random()*(TETRO_TYPES.length-1))+1;
        tetro = TETRO_TYPES[ num ];  //変数tetroに7種類のテトロミノのうちどれか1つが入ったぞ！
        

        //FIELD_ROW(20行）*FIELD_COL(10列)の二次元配列を初期化する関数（20行*10列の二次元配列全てに0を入れる）
        function init()
        {
            for(let y=0; y<FIELD_ROW; y++)  
            {
                field[y] = [];  //field[y]に配列を入れると言っている

                for(let x=0; x<FIELD_COL; x++)
                {
                    field[y][x] = 0;
                }
            }
                // テスト
                // field[5][8] = 1;
                // field[19][0] = 1;
                // field[19][9] = 1;
        }    



        init();
        drawAll();

        //setTimeoutでGAME＿SPEEDごとにdropTetroを繰り返す。このサイトを参考にした：https://techacademy.jp/magazine/5537
        let drop = function(){
            dropTetro();
            setTimeout(drop,GAME_SPEED);
            }
            drop();


        //スタートボタンが押された時に動く関数がこれ。でもスタートボタン押した後にスペースキーを押すとこの関数が動いてしまうバグがある。
        function Startbtn(){
            console.log("スタート動いた")
        };

        
        function ResetBtn(){
            window.location.reload(); //画面のリロード。F5ボタン押すのと同じ。
        };


        // ブロック１つを描画する関数
        function drawBlock(x, y, c)
        {
            let px = x * BLOCK_SIZE;
            let py = y * BLOCK_SIZE;

            con.fillStyle=TETRO_COLORS[c];  //fillStyleは塗りつぶし
            con.fillRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
            con.strokeStyle = "black";  //ブロックの枠線
            con.strokeRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
        }

        //フィールド、テトリミノを描画する関数[drawAll]
        function drawAll()
        {
            con.clearRect(0, 0, SCREEN_W, SCREEN_H) //描画する直前に描画をクリアする
            // 10*20のフィールドをfor文で表現する
            for(let y=0; y<FIELD_ROW; y++)
            {
                for(let x=0; x<FIELD_COL; x++)
                {
                    if( field[y][x])
                    {
                        drawBlock(x, y, field[y][x]);    //上で宣言した[ブロック１つを描画する関数]
                    }
                }
            }
            
            // 変数tetroは二次元配列。二次元配列が 1 の時にブロックを描画する
            for(let y=0; y<TETRO_SIZE; y++){
                for(let x=0; x<TETRO_SIZE; x++){
                    if( tetro[y][x] ){
                        drawBlock(tetro_x+x, tetro_y+y, num);  //上で宣言した[ブロック１つを描画する関数]
                    }
                }
            }


            if(gameover) //gameoverがtrueなら
            {
                document.getElementById("GAMEOVER").innerHTML = "ゲームオーバー";
                document.body.style.backgroundColor = '#ff99cc';
                document.getElementById("reset").disabled = false;  //リセットボタンを有効にする
                final_line_count = line_count;
                console.log("最終スコア",final_line_count);

            }
        }



        //テトロミノの落ちるところの処理
        function dropTetro()
        {
            if(gameover) return;  //ゲームオーバーフラグがtrueならreturnしちゃう

            if( checkMove( 0, 1 )) tetro_y++; //下にブロックがなければ下に落ち続ける
            else
            {  
                fixTetro();
                checkLine();

                num = Math.floor(Math.random()*(TETRO_TYPES.length-1))+1;
                tetro = TETRO_TYPES[ num ];

                tetro_x = START_X;
                tetro_y = START_Y;

                if( !checkMove( 0, 0 ))
                {
                    gameover = true;
                }

            }

            drawAll();
        }

    // ブロックの衝突判定
        function checkMove(mx, my, newtetro)
        {
            if( newtetro === undefined) newtetro = tetro;  //newtetroが存在しないなら、元のまま。
            
            for(let y=0; y<TETRO_SIZE; y++)
            {
                for(let x=0; x<TETRO_SIZE; x++)
                {
                    let nx = tetro_x + mx + x;
                    let ny = tetro_y + my + y;
                    if( newtetro[y][x] )
                    {
                        if( 
                            ny < 0 ||
                            nx < 0 ||
                            ny >= FIELD_ROW ||
                            nx >= FIELD_COL ||
                            field[ny][nx]
                        )
                            {
                                return false;
                            }
                    }

                }
            }
            return true;
        }

        // テトロミノの回転
        function rotate()
        {
            let newtetro = [];  //回転後のテトロミノの座標

            for(let y=0; y<TETRO_SIZE; y++)
            {
                newtetro[y] = []; //配列化
                for(let x=0; x<TETRO_SIZE; x++)
                {
                    newtetro[y][x] = tetro[TETRO_SIZE-1-x][y]; //右回りに回転させるとこうなる
                }
            }
            return newtetro;
        }

        //ラインが揃ったかチェックし、揃っていたら上の行を一つ下にずらす。
        function checkLine()
        {
            for(let y=0; y<FIELD_ROW; y++)
            {
                let flag = true;
                for(let x=0; x<FIELD_COL; x++)
                {
                    if( !field[y][x] )
                    {
                        flag=false;
                        break;
                    }
                }

                if(flag)
                {
                    line_count++;  //ラインを揃えた回数を増やす
                    document.getElementById("line_c").innerHTML = line_count; //画面上に表示する
                    if(line_count % 2 === 0)GAME_SPEED -= 100;  //line_count（消したラインの数）が2の倍数の時にゲームスピードを100減らす

                    
                    for(let ny = y; ny>0 ; ny--)
                    {
                        for(let nx=0 ; nx<FIELD_COL ; nx++)
                        {
                            field[ny][nx] = field[ny-1][nx];
                        }
                    }
                }
            }

        console.log("line_count",line_count);
        console.log("GAME_SPEED",GAME_SPEED);
        console.log("NEW_GAME_SPEED",NEW_GAME_SPEED);
        }

        

        //下まで落ちたテトロミノの固定
        function fixTetro()
        {
            for(let y=0; y<TETRO_SIZE; y++)
            {
                for(let x=0; x<TETRO_SIZE; x++)
                {
                    if( tetro[y][x])
                    {
                        field[tetro_y + y][tetro_x + x] = num;
                    }

                }

            }
        }

        

        


        //キーボードが押された時のアクション
        document.onkeydown = function(e)
        {
            if(gameover) return;  //ゲームオーバーフラグがtrueならreturnしちゃう

            switch( e.keyCode )
            {
                case 37:  //左のボタンを押した時
                    if( checkMove( -1, 0 )) 
                    tetro_x--; //x座標をマイナス
                    break;

                // case 38:  //上
                //     let newtetro = rotate();//rotate()はテトロミノの回転の関数。戻り値は回転後のテトロミノの座標。
                //     if( checkMove( 0, 0, newtetro) ) tetro = newtetro;
                //     break;
                    
                case 39:  //右
                    if( checkMove( 1, 0 )) 
                    tetro_x++;
                    break;

                case 40:  //下
                    if( checkMove( 0, 1 )) 
                    tetro_y++;
                    break;

                case 32:  //スペースキー
                    let newtetro = rotate();//rotate()はテトロミノの回転の関数。戻り値は回転後のテトロミノの座標。
                    if( checkMove( 0, 0, newtetro) ) tetro = newtetro;
                    break;
            }

            drawAll();  
        }




    </script>



</body>
</html>